# Syllabus for _COMP6770 Programming Principles and Practices_

Copyright (c) Christopher Di Bella 2017

## Contents

1. Program of Study
2. Rationale for COMP6770
4. Aim
5. Objectives
6. Course structure
7. Objectives and outcomes
   1. Table of objectives and outcomes
   2. Key competencies
8. Content
9. Course requirements
10. Assessment and reporting

## Program of study

The purpose of the Program of Study is to:

* provide a clear structure for students to complete their parent program (for example, Bachelor of
  Computer Science);
* foster the development of:
   * learning and future development,
   * knowledge and skills relevant to the industrial applications of this topic, and
   * working with others;
* provide a structure that:
   * offers students a window into programming principles and practices,
   * offers students an opportunity to pursue more mature topics at this course's end
   * seek employment following this course
   * contribute to open source projects following this course;
* provide formal assessment to validate the development of student objectives and outcomes;
* provide a guideline for students to know what to expect from this course;
* provide a guideline for future course developers to work from

## Rationale for COMP6770

The purpose of this course is to teach computer programming, and the fundamental principles and
practices that accompany well-engineered systems. The subject offers students formal methods of
assessment, which they can use to further develop their skills in problem solving, logic, and
software development.

This course has been designed to be taken by anyone with or without knowledge of computer
programming. As such, the first few weeks of this course might be considered 'boring' for
experienced programmers -- at a first glance. The content is designed in such a way that all
students should be engaged from the first point of contact. As such, experienced programmers are
encouraged to attend all classes, even if the content appears to cover materials that they would
otherwise know.

This course teaches its programming principles and practices using the C++ programming language.
The focus of this course is not to teach C++ language features: that is a by-product of the way in
which material is delivered. Students wishing to learn C++ as quickly as possible should know that
learning C++ language features and learning how to write well-engineered program using C++ are two
different goals, and that the former can often lead to poor software engineering practices using
C++.

This course is a prerequisite for:

* _COMP6771 Advanced C++ Programming_, which dives deeper into the C++ programming language, and is
  suitable for programmers wishing to enter domains that are heavily reliant on C++ library
  development, and
* _COMP6772 Heterogeneous Programming_, which teaches how to harness parallel programming across
  multiple devices using SYCL.

## Aim

_COMP6770 Programming Principles and Practices_ aims to develop students' skills and understanding
of the principles of software engineering practice using the C++ programming language.

## Objectives

Students will develop:

1. knowledge and understanding about how software engineers build systems
2. knowledge and understanding about why unit-testing and integration-testing are important steps in
   software development
3. knowledge and understanding about why benchmarking is an important step in software development
4. knowledge and understanding about software engineering tools
5. skills in the C++ programming language
6. skills in testing software solutions
7. skills in benchmarking software solutions
8. skills in using multiple compilers
9. skills in using a lint tool
10. skills in using the version control tool Git and the hosting platform GitHub
11. skills in using the build system CMake
12. skills in using the continuous integration tool TravisCI
13. skills in using the debugger GDB
14. skills in using the profilers
    1. AddressSanitizer
    2. UndefinedBehaviorSanitizer
15. skills in teamwork, communication, and collaboration associated with the design and development
    of software solutions[1].

## Course structure

The course is split into four main topics. They are discussed in detail in the [Content](#content)
section.

1. Basics
2. Input and output
3. Data and algorithms
4. Broadening the view

## Objectives and outcomes

### Table of objectives and outcomes

| Objective                                                                                     | Outcome                                                                                                                       |
|-----------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|
| Students will develop                                                                         | A student                                                                                                                     |
|                                                                                               |                                                                                                                               |
| 1. knowledge and understanding about how software engineers build systems                     | P1.1 chooses the correct data structures, algorithms, libraries, and tools for engineering software                           |
|                                                                                               | P1.2 consults the most appropriate resources for building a system                                                            |
| 2. knowledge and understanding about why testing is an important for software development     | P2.1 designs unit-tests to validate that the individual components of their are correct                                       |
|                                                                                               | P2.2 designs integration-tests to validate that their individual components work together to provide the correct solution     |
| 3. knowledge and understanding about why benchmarking is important for software development   | P3.1 designs benchmarks to prove that one choice is "more efficient" than another                                             |
| 4. knowledge and understanding about software engineering tools                               | P4.1 chooses the correct tools to help solve the problem                                                                      |
| 5. skills in the C++ programming language                                                     | P5.1 wirtes programs that correctly sovle the problem using C++                                                               |
|                                                                                               | P5.2 writes programs that take advantage of modern C++ programming techniques                                                 |
|                                                                                               | P5.3 reads and understands existing C++ code to understand the current state of a solution                                    |
|                                                                                               | P5.4 modifies or extends existing C++ code without the need for major rewrites to well-written code                           |
| 6. skills in testing software solutions                                                       | P6.1 writes unit-tests using the Catch2 framework                                                                             |
|                                                                                               | P6.2 writes integration-tests using the 
| 7. skills in benchmarking software solutions                                                  | P7.1 writes benchmarks to determine if one design decision is "more efficient" than another                                   |
|                                                                                               | P7.2 writes benchmarks to determine if their solution meets the performance requirements outlined by a specification          |
| 8. skills in using multiple compilers                                                         | P8.1 writes code conforming to _ISO/IEC 14882:2017_ so that it can be targeted on more than one system                        |
|                                                                                               | P8.2 compiles using high levels of warnings                                                                                   |
|                                                                                               | P8.3 compiles with debugging symbols when they need to understand why their program is failing to produce the expected result |
|                                                                                               | P8.4 compiles with optimisations when they want to run the program in the 'real world' or are performing benchmarks           |
| 9. skills in using a lint tool                                                                | P9.1 uses a lint tool (such as clang-tidy) to catch easy-to-make-but-hard-to-spot-mistakes                                    |
|                                                                                               | P9.2 configures the lint tool to match the goals and ethics of the course                                                     |
| 10. skills in using the version control tool Git and the hosting platform GitHub              | P10.1 creates repositories on GitHub                                                                                          |
|                                                                                               | P10.2 regularly commits changes to repositories                                                                               |
|                                                                                               | P10.3 branches, merges, and rebases as new features are added to a project                                                    |
|                                                                                               | P10.4 pushes commits and branches to a remote repository (on GitHub)                                                          |
|                                                                                               | P10.5 tracks issues through GitHub's issue tracker                                                                            |
|                                                                                               | P10.6 performs Pull Requests to engage in code reviews with collaborators (students and markers)                              |
| 11. skills in using the build system                                                          | P11.1 sets up a project structure suitable for modern C++ development                                                         |
|                                                                                               | P11.2 writes scripts that automate their builds                                                                               |
|                                                                                               | P11.3 automates their builds using their build system                                                                         |
| 12. skills in using the continuous integration tool TravisCI                                  | P12.1 integrates their GitHub project with TravisCI                                                                           |
|                                                                                               | P12.2 writes basic scripts to automate their testing when pushing to their remote repository                                  |
| 13. skills in using debuggers compatible with the course compilers                            | P13.1 uses debuggers to pinpoint flaws in their program design                                                                |
| 14. skills in using profilers                                                                 | P14.1 
|                                                                                               | P14.2
|                                                                                               | P14.3
| 15. skills in teamwork, communication, and collaboration associated with software engineering | P15.1 collaborates with other students to design solutions                                                                    |
|                                                                                               | P15.2 collaborates with other students for code reviews                                                                       |
|                                                                                               | P15.3 collaborates with other students when in need of assistance (or to provide assistance)                                  |

At as of 2017-10-14, in order to satisfy certain Objectives, certain tools are recommended.

| Objective | Tool(s)                    | Version |
|-----------|----------------------------|---------|
| 8         | GCC                        | 7       |
|           | LLVM (Clang)               | 5       |
| 11        | CMake                      | 3.10    |
| 13        | GDB (for GCC)              | 7.2     |
|           | LLDB (for LLVM)            | 5       |
| 14        | AddressSanitizer           | n/a     |
|           | UndefinedBehaviorSanitizer | n/a     |
|           | Valgrind                   | 3.13    |

As a follow-up, Microsoft Visual Studio Code is a good cross-platform tool that allows for editing
and integration with many of the tools that students will need to use.

### Key competencies
## Content

### Basics

Students are introduced to the principles and practices employed by software developers. Students
without prior programming experience will be exposed to programming for the first time. Students
with prior programming experience will receive a refresher on this topic, which will help provide a
solid foundation for their learning throughout the remainder of the course (and program).

This topic focuses on the core components that compose a basic program.

#### Outcomes

A student:

* P1.1 chooses the correct data structures, algorithms, libraries, and tools for engineering
  software
* P1.2 consults the most appropriate resources for building a system
* P5.1 wirtes programs that correctly sovle the problem using C++
* P5.2 writes programs that take advantage of modern C++ programming techniques
* P6.1 writes unit-tests using the Catch2 framework
* P8.1 writes code conforming to _ISO/IEC 14882:2017_ so that it can be targeted on more than one
  system
* P8.2 compiles using high levels of warnings
* P8.3 compiles with debugging symbols when they need to understand why their program is failing to
  produce the expected result
* P8.4 compiles with optimisations when they want to run the program in the 'real world' or are
  performing benchmarks
* P9.1 uses a lint tool (such as clang-tidy) to catch easy-to-make-but-hard-to-spot-mistakes
* P9.2 configures the lint tool to match the goals and ethics of the course
* P10.1 creates repositories on GitHub
* P10.2 regularly commits changes to repositories
* P10.3 branches, merges, and rebases as new features are added to a project
* P10.4 pushes commits and branches to a remote repository (on GitHub)
* P10.5 tracks issues through GitHub's issue tracker
* P10.6 performs Pull Requests to engage in code reviews with collaborators (students and markers)
* P13.1 uses debuggers to pinpoint flaws in their program design
* P15.3 collaborates with other students when in need of assistance (or to provide assistance)

<table>
  <tr>
    <td><h2>Students learn about<h2></td><td><h2>Students learn to</h2></td>
  </tr>
  <tr>
    <td>
      <b>Hello, world!</b>
      <ul>
        <li>what comprises software</li>
        <li>the absolute fundamentals of a C++ program</li>
        <li><code>#include</code> directives
        <li>the <code>main</code> function</li>
        <li>put-to expressions</li>
        <li>compilers</li>
      </ul>
    </td>
    <td><ul>
      <li>write simple computer programs</li>
      <li>compile computer programs</li>
    </ul></td>
  </tr>
  <tr>
    <td>
      <b>Objects, types, values</b>
      <ul>
        <li>
          objects, types, values
          <ul>
            <li><code>int</code> for integers</li>
            <li><code>double</code> for rational numbers</li>
            <li><code>char</code> for individual characters</li>
            <li><code>string</code> for strings</li>
            <li><code>bool</code> for Boolean values</li>
            <li><code>auto</code> for automatic type deduction</li>
          </ul>
        </li>
        <li>
          variables
          <ul>
            <li><code>constexpr</code> variables</li>
            <li><code>const</code> variables</li>
            <li>Mutable variables</li>
          </ul>
        <li>
          expressions
          <ul>
            <li>get-from expressions</li>
            <li>arithmetic expressions</li>
            <li>comparison expressions</li>
            <li>assignment expressions</li>
          </ul>
        </li>
        <li>lint tools</li>
        <li>
          conversions
          <ul>
            <li>safe conversions</li>
            <li>unsafe conversions</li>
          </ul>
        </li>
      </ul>
    </td>
    <td>
      <ul>
        <li>choose appropriate data types for their objects' situation</li>
        <li>prefer named constant expressions over variables</li>
        <li>initialise variables at definition</li>
        <li>let the compiler decide the type at compile-time</li>
        <li>declare names as close to their first use as possible</li>
        <li>run a lint tool to check their code is correct</li>
        <li>avoid unsafe conversions</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>
      <b>Computation</b>
      <ul>
        <li>why computation is necessary</li>
        <li>what a programmer's job is</li>
        <li>
          sequence
          <ul>
            <li>expressions</li>
            <li>constant expressions</li>
            <li>conversions</li>
          </ul>
        </li>
        <li>
          selection
          <ul>
            <li><code>if</code>-statements</li>
            <li><code>switch</code>-statements</li>
          </ul>
        </li>
        <li>
          iteration
          <ul>
            <li><code>while</code>-statements</li>
            <li><code>for</code>-statements</li>
          </ul>
        </li>
        <li>code blocks</li>
        <li>
          functions
          <ul>
            <li>definitions</li>
            <li>declarations</li>
            <li>compile-time functions</li>
            <li>pre-conditions</li>
            <li>post-conditions</li>
            <li>regular functions</li>
          </ul>
        </li>
        <li>
          Storing collections
          <ul>
            <li><code>vector</code></li>
            <li>
              <code>vector</code> traversal
              <ul>
                <li><code>operator[]</code></li>
                <li>Range-<code>for</code>-statements</li>
              </ul>
            </li>
            <li>adding elements</li>
            <li>summing elements</li>
            <li>counting elements</li>
            <li>finding elements</li>
            <li>removing elements</li>
          </ul>
        </li>
      </ul>
    </td>
    <td><ul>
      <li>prefer composing logic in order of correctness, simplicity, and efficiency</li>
      <li>
        compose logic using <code>if</code>-, <code>switch</code>-, <code>while</code>-, and
        <code>for</code>-statements
      </li>
      <li>define functions other than <code>main</code></li>
      <li>define functions that execute at compile-time instead of run-time</li>
      <li>declare functions</li>
      <li>store related objects in a <code>vector</code></li>
      <li>perform simple operations on a <code>vector</code></li>
    </ul></td>
  </tr>
  <tr>
    <td>
      <b>Errors</b>
      <ul>
        <li>
          compile-time errors
          <ul>
            <li>syntax errors</li>
            <li>type errors</li>
            <li>non-errors</li>
          </ul>
        </li>
        <li>link-time errors</li>
        <li>run-time errors</li>
        <li>exceptions</li>
        <li>logic errors</li>
        <li>simple test cases in Catch2</li>
        <li>
          debuggers and debugging
          <ul>
            <li>breakpoints</li>
            <li>stepping through code</li>
            <li>stepping over code</li>
            <li>stepping out of code</li>
            <li>inspecting variables</li>
            <li>TUI-mode (optional: only relevant in command-line GDB)</li>
            <li>how to simplify debugging</li>
          </ul>
        </li>
      </ul>
    </td>
    <td>
      <ul>
        <li>prefer compile-time errors to run-time errors and logic errors</li>
        <li>use exceptions to handle run-time errors</li>
        <li>write unit-tests</li>
        <li>think about debugging <i>before</i> writing code<li>
        <li>debug programs when tests fail</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>
      <b>Writing a program</b>
      <ul>
        <li>Git and GitHub
          <ul>
            <li>creating repositories</li>
            <li>cloning repositories</li>
            <li>committing changes</li>
            <li>pushing changes to a remote</li>
          </ul>
        </li>
        <li>approaching problem solving</li>
        <li>string processing and tokens</li>
        <li>grammars</li>
        <li>trying a first version</li>
        <li>trying a second version</li>
        <li>token streams</li>
      </ul>
    </td>
    <td><ul>
      <li>create a GitHub repository</li>
      <li>clone a repository from GitHub</li>
      <li>commit changes to a Git repository</li>
      <li>push commits to a remote Git repository (GitHub)</li>
      <li>plan solutions instead of jumping directly to programming</li>
      <li>experiment with different solutions</li>
      <li>critique and improve their solution</li>
      <li>// TODO</li>
    </ul></td>
  </tr>
  <tr>
    <td>
      <b>Completing a program</b>
      <ul>
        <li>Git branches, merging, rebasing, and cherrypicking</li>
        <li>determining if their solution actually solves the problem</li>
        <li>more advanced tests with Catch2</li>
      </ul>
    </td>
    <td><ul>
      <li>create branches in Git repositories for changes</li>
      <li>merge Git branches once work is complete</li>
      <li>merge a single commit to a Git branch from many</li>
      <li>squash Git branches when only one commit is ideal</li>
      <li>perform code reviews via GitHub pull requests</li>
      <li>critique and improve their solution</li>
      <li>implement more rigorous tests</li>
      <li>// completing a program here</li>
    </ul></td>
  </tr>
</table>

### Input and output

<table>
  <tr>
    <td><b>Students learn about</b></td>
    <td><b>Students learn to</b></td>
  </tr>
  <tr>
    <td>
      <b>Input and output streams</b>
    </td>
    <td></td>
  </tr>
  <tr>
    <td>
      <b>Customising input and output</b>
    </td>
    <td></td>
  </tr>
  <tr>
    <td>
      <b>A display model</b>
    </td>
    <td></td>
  </tr>
  <tr>
    <td>
      <b>Graphics</b>
    </td>
    <td></td>
  </tr>
  <tr>
    <td>
      <b>Graphing functions and data</b>
    </td>
    <td></td>
  </tr>
  <tr>
    <td>
      <b>Graphical user interfaces</b>
    </td>
    <td></td>
  </tr>
</table>


### Data and algorithms
<table>
  <tr>
    <td><b>Vector and Free Store</b></td>
    <td></td>
  </tr>
  <tr>
    <td><b>Vectors and arrays</b></td>
    <td></td>
  </tr>
  <tr>
    <td><b>Vector, templates, and exceptions</b></td>
    <td></td>
  </tr>
  <tr>
    <td><b>Containers and iterators</b></td>
    <td></td>
  <tr>
    <td><b>Algorithms and maps</b></td>
    <td></td>
  </tr>
</table>

### Broadening the view
<table>
  <tr>
    <td>
      <b>Ideals and history</b>
    </td>
    <td></td>
  </tr>
  <tr>
    <td><b>Text manipulation</b></td>
    <td></td>
  </tr>
  <tr>
    <td><b>Numerics</b></td>
    <td></td>
  </tr>
  <tr>
    <td><b>Embedded systems programming<b></td>
    <td></td>
  </tr>
  <tr>
    <td><b>Parallel programming</b></td>
    <td></td>
  </tr>
  <tr>
    <td><b>Testing</b></td>
    <td></td>
  </tr>
  <tr>
  <tr>
    <td><b>The C Programming Language</b></td>
  </tr>
</table>

## Course requirements

This course has no formal requirements. Students enrolling in the course are assumed to have
developed intermediate skills in high school calculus and algebra:

* 
* 
* 
* 
* 
* 

Students who have not developed the above skills will likely struggle with the course material.

### When to study this course

This course is best studied during the first semester of a computer science or engineering program,
absent of other programming courses (particularly ones that teach C, Java, C#, or Python). It is
understood that many university programs will have strict curriculums and that students probably
cannot meet this recommendation (or are advised by their faculty to avoid following it). As such,
the next recommended time to study this course is after a third semester of university, so that this
course may serve as a refresher for the things that students have forgotten or disregarded since
their first year of university. Given that this course doubles as 'the C++ course', students will
need to take this course if they wish to formally learn C++, or in the case that they've already
learnt C++, deepen their learning.

## Post-course opportunities

Computer software is used in everyday life to the point where a large portion of the global
population now depend upon it for survival. Software is becoming evermore complex; this course does
not aim to make you a software engineering expert. It aims to give you a rich toolset so that you
may enter the workforce with enough knowledge to become an expert in time.

[Many software solutions have been developed with C++](stroustrup.com/applications.html). Many more
are not listed, but if you found this course interesting and keep practicing, you might like to
consider applying for a software engineering position with:

<table>
  <tr><td>A9 (Amazon)</td><td>Adobe Systems</td><td>AMD</td><td>Bethesda Game Studios</td></tr>
  <tr><td>Bloomberg</td><td>Boeing</td><td>Codeplay Software</td><td>Coverity</td></tr>
  <tr><td>Creative Assembly</td><td>Crytek</td><td>Dropbox</td><td>DRW Trading Group</td></tr>
  <tr><td>Facebook</td><td>Google</td><td>id</td><td>Imagination Technologies</td></tr>
  <tr><td>IMC</td><td>Intel</td><td>Microsoft</td><td>Morgan Stanley</td></tr>
  <tr><td>Naughty Dog</td><td>Nintendo</td><td>nVidia</td><td>Occulus</td></tr>
  <tr><td>Qualcomm</td><td>Renesas</td><td>Sony</td><td>Valve</td>
</table>

This course is not affiliated with any of the listed companies, nor does it guarantee you a position
with any of them.

## Contact hours

This syllabus recommends the following as a minimum number of hours students should spend
interacting with university staff:

| Component | Recommended time                           |
|-----------|--------------------------------------------|
| Lectures  | Four hours, split into two two-hour blocks |
| Tutorials | One hour per week                          |
| Labs      | Two hours per week, separate to tutorials  |

## Assessment and reporting

The course is designed to have weekly laboratories and four assignments. Both are expected to take a
significant portion of your study week. There is a final practical exam at the end of the course.

| Assessment  | Weighting | Minimum mark to pass the course | Supplementary                                 |
|-------------|-----------|---------------------------------|-----------------------------------------------|
| Labs        | 15%       | 7/15                            | No, but only your top ten labs are marked     |
| Assignments | 35%       | 18/35                           | No, but extensions are possible in some cases |
| Exam        | 50%       | 25/50                           | Yes, but there will be an oral component too  |

Students who are unable to submit labs can contact their tutor and the lecturer in charge to arrange
for the weighting of this component to be transferred to the final exam (total weighting 65%). In
this case, your exam will also have an oral component. The oral section is necessary to help combat
academic misconduct, and to keep matters fair -- each lab has an oral section too.

Each lab is designed so that you have an individual component and a group component. Failure to
satisfactorily complete the group component will result in a zero for your individual component.
Failing to complete the group component three or more times will have their final mark capped at
**45 FL**. Students affected by inactive group members will be given the option to complete anything
that can be completed by the following lab. Furthermore, the group component is (usually) only worth
a total of 20% for each lab (usually a code review). Three of the labs will have a group component
worth 60% of the lab.

## Prescribed texts

The prescribed text for this course is _Programming -- Principles and Practice Using C++ (Second
ediition)_, by Bjarne Stroustrup.

There will be prescribed readings, and many of the tutorial and laboratory questions will be derived
from this book, so it is _strongly_ recommended that you purchase a copy in Week 1. Some content
will only be available from the textbook.

## Recommended texts

* Students familiar with another programming language may like to read _A Tour of C++_, by Bjarne
  Stroustrup before they begin PPP; this will given you a taste of what is to come, without bogging
  you down in the details.
* Students wishing to have a reference handy should consult [C++ Reference](en.cppreference.com).
* Students wishing to have a reference with rational handy should consult _The C++ Programming
  Language (Fourth edition)_, by Bjarne Stroustrup.
* We will be using the [_C++ Core Guidelines_] as a 'style guide'. You aren't required to read this
  (it is very large), but if you are interested, you might like to take a peek.

## References


# Syllabus for _COMP6770 Programming Principles and Practices_

Copyright (c) Christopher Di Bella 2017

## Contents

1. Program of Study
2. Rationale for COMP6770
4. Aim
5. Objectives
6. Course structure
7. Objectives and outcomes
   1. Table of objectives and outcomes
   2. Key competencies
8. Content
9. Course requirements
10. Assessment and reporting

## Program of study

The purpose of the Program of Study is to:

* provide a clear structure for students to complete their parent program (for example, Bachelor of
  Computer Science);
* foster the development of:
   * learning and future development,
   * knowledge and skills relevant to the industrial applications of this topic, and
   * working with others;
* provide a structure that:
   * offers students a window into programming principles and practices,
   * offers students an opportunity to pursue more mature topics at this course's end
   * seek employment following this course
   * contribute to open source projects following this course;
* provide formal assessment to validate the development of student objectives and outcomes;
* provide a guideline for students to know what to expect from this course;
* provide a guideline for future course developers to work from

## Rationale for COMP6770

The purpose of this course is to teach computer programming, and the fundamental principles and
practices that accompany well-engineered systems. The subject offers students formal methods of
assessment, which they can use to further develop their skills in problem solving, logic, and
software development.

This course has been designed to be taken by anyone with or without knowledge of computer
programming. As such, the first few weeks of this course might be considered 'boring' for
experienced programmers -- at a first glance. The content is designed in such a way that all
students should be engaged from the first point of contact. As such, experienced programmers are
encouraged to attend all classes, even if the content appears to cover materials that they would
otherwise know.

This course teaches its programming principles and practices using the C++ programming language.
The focus of this course is not to teach C++ language features: that is a by-product of the way in
which material is delivered. Students wishing to learn C++ as quickly as possible should know that
learning C++ language features and learning how to write well-engineered program using C++ are two
different goals, and that the former can often lead to poor software engineering practices using
C++.

This course is a prerequisite for:

* _COMP6771 Advanced C++ Programming_, which dives deeper into the C++ programming language, and is
  suitable for programmers wishing to enter domains that are heavily reliant on C++ library
  development, and
* _COMP6772 Heterogeneous Programming_, which teaches how to harness parallel programming across
  multiple devices using SYCL.

## Aim

_COMP6770 Programming Principles and Practices_ aims to develop students' skills and understanding
of the principles of software engineering practice using the C++ programming language.

## Objectives

Students will develop:

1. knowledge and understanding about how software engineers build systems
2. knowledge and understanding about why unit-testing and integration-testing are important steps in
   software development
3. knowledge and understanding about why benchmarking is an important step in software development
4. knowledge and understanding about software engineering tools
5. skills in the C++ programming language
6. skills in testing software solutions
7. skills in benchmarking software solutions
8. skills in using multiple compilers
9. skills in using a lint tool
10. skills in using the version control tool Git and the hosting platform GitHub
11. skills in using the build system CMake
12. skills in using the continuous integration tool TravisCI
13. skills in using the debugger GDB
14. skills in using the profilers
    1. AddressSanitizer
    2. UndefinedBehaviorSanitizer
15. skills in teamwork, communication, and collaboration associated with the design and development
    of software solutions[1].

## Course structure

The course is split into four main topics. They are discussed in detail in the [Content](#content)
section.

1. Basics
2. Input and output
3. Data and algorithms
4. Broadening the view

## Objectives and outcomes

### Table of objectives and outcomes

<table>
  <tr>
    <td><b>Objective</b></td>
    <td><b>Outcome</b></td>
  </tr>
  <tr>
    <td>Students will develop</td>
    <td>A student</td>
  </tr>
  <tr>
    <td>1. knowledge and understanding about how software engineers build systems</td>
    <td><dl>
      <dt>P1.1</dt>
      <dd>
        chooses the correct data structures, algorithms, libraries, and tools for engineering
        software
      </dd>
      <dt>P1.2</dt>
      <dd>consults the most appropriate resources for building a system</dd>
    </dl></td>
  </tr>
  <tr>
    <td>2. knowledge and understanding about why testing is an important for software development</td>
    <td><dl>
      <dt>P2.1</dt>
      <dd>designs unit-tests to validate that the individual components of their are correct</dd>
      <dt>P2.2</dt>
      <dd>
        designs integration-tests to validate that their individual components work together to
        provide the correct solution
      </dd>
    </dl></td>
  </tr>
  <tr>
    <td>3. knowledge and understanding about why benchmarking is important for software development</td>
    <td><dl>
      <dt>P3.1</dt>
      <dd>designs benchmarks to prove that one choice is "more efficient" than another</dd>
    </dl></td>
  </tr>
  <tr>
    <td>4. knowledge and understanding about software engineering tools</td>
    <td><dl>
      <dt>P4.1</dt>
      <dd>chooses the correct tools to help solve the problem</dd>
    </dl></td>
  </tr>
  <tr>
    <td>5. skills in the C++ programming language</td>
    <td><dl>
      <dt>P5.1</dt>
      <dd>wirtes programs that correctly sovle the problem using C++</dd>
      <dt>P5.2</dt>
      <dd>writes programs that take advantage of modern C++ programming techniques</dd>
      <dt>P5.3</dt>
      <dd>reads and understands existing C++ code to understand the current state of a solution</dd>
      <dt>P5.4</dt>
      <dd>
        modifies or extends existing C++ code without the need for major rewrites to well-written
        code
      </dd>
    </dl></td>
  </tr>
  <tr>
    <td>6. skills in testing software solutions</td>
    <td><dl>
      <dt>P6.1</dt>
      <dd>writes unit-tests using the Catch2 framework</dd>
      <dt>P6.2</dt>
      <dd>writes integration-tests using the </dd>
    </dl></td>
  </tr>
  <tr>
    <td>7. skills in benchmarking software solutions</td>
    <td><dl>
      <dt>P7.1</dt>
      <dd>
        writes benchmarks to determine if one design decision is "more efficient" than another
      </dd>
      <dt>P7.2</dt>
      <dd>
        writes benchmarks to determine if their solution meets the performance requirements
        outlined by a specification
      </dd>
    </td>
  </tr>
  <tr>
    <td>8. skills in using multiple compilers</td>
    <td><dl>
      <dt>P8.1</dt>
      <dd>
        writes code conforming to <i>ISO/IEC 14882:XXXX</i> so that it can be targeted on more than
        one system
      </dd>
      <dt>P8.2</dt>
      <dd>compiles using high levels of warnings</dd>
      <dt>P8.3</dt>
      <dd>
        compiles with debugging symbols when they need to understand why their program is failing to
        produce the expected result
      </dd>
      <dt>P8.4</dt>
      <dd>
        compiles with optimisations when they want to run the program in the 'real world' or are
        performing benchmarks
      </dd>
    </dl></td>
  </tr>
  <tr>
    <td>9. skills in using a lint tool</td>
    <td><dl>
      <dt>P9.1</dt>
      <dd>uses a lint tool to catch easy-to-make-but-hard-to-spot-mistakes</dd>
      <dt>P9.2</dt>
      <dd>configures the lint tool to match the goals and ethics of the course</dd>
    </dl></td>
  </tr>
  <tr>
    <td>10. skills in using the version control tool Git and the hosting platform GitHub</td>
    <td><dl>
      <dt>P10.1</dt><dd>creates repositories on GitHub</dd>
      <dt>P10.2</dt><dd>regularly commits changes to repositories</dd>
      <dt>P10.3</dt><dd>branches, merges, and rebases as new features are added to a project</dd>
      <dt>P10.4</dt><dd>pushes commits and branches to a remote repository (on GitHub)</dd>
      <dt>P10.5</dt><dd>tracks issues through GitHub's issue tracker</dd>
      <dt>P10.6</dt>
      <dd>
        performs Pull Requests to engage in code reviews with collaborators (students and markers)
      </dd>
    </dl></td>
  </tr>
  <tr>
    <td>11. skills in using the build system</td>
    <td><dl>
      <dt>P11.1</dt><dd>sets up a project structure suitable for modern C++ development</dd>
      <dt>P11.2</dt><dd>writes scripts that automate their builds</dd>
      <dt>P11.3</dt><dd>automates their builds using their build system</dd>
    </dl></td>
  </tr>
  <tr>
    <td>12. skills in using the continuous integration tool TravisCI</td>
    <td><dl>
      <dt>P12.1</dt><dd>integrates their GitHub project with TravisCI</dd>
      <dt>P12.2</dt>
      <dd>
        writes basic scripts to automate their testing when pushing to their remote repository
      </dd>
    </dl></td>
  </tr>
  <tr>
    <td>13. skills in using debuggers compatible with the course compilers</td>
    <td><dl><dt>P13.1</dt><dd>uses debuggers to pinpoint flaws in their program design</dd></td>
  </tr>
  <tr>
    <td>14. skills in using profilers</td>
    <td>TODO</td>
  </tr>
  <tr>
    <td>
      15. skills in teamwork, communication, and collaboration associated with software engineering
    </td>
    <td><dl>
      <dt>P15.1</dt><dd>collaborates with other students to design solutions</dd>
      <dt>P15.2</dt><dd>collaborates with other students for code reviews</dd>
      <dt>P15.3</dt>
      <dd>
        collaborates with other students when in need of assistance (or to provide assistance)
      </dd>
    </dl></td>
  </tr>
</table>

At as of 2017-10-14, in order to satisfy certain Objectives, certain tools are recommended.

| Objective | Tool(s)                    | Version |
|-----------|----------------------------|---------|
| 8         | GCC                        | 7       |
|           | LLVM (Clang)               | 5       |
| 9         | Clang Tidy                 | 5       |
| 11        | CMake                      | 3.10    |
| 13        | GDB (for GCC)              | 7.2     |
|           | LLDB (for LLVM)            | 5       |
| 14        | AddressSanitizer           | n/a     |
|           | UndefinedBehaviorSanitizer | n/a     |
|           | Valgrind                   | 3.13    |

As a follow-up, Microsoft Visual Studio Code is a good cross-platform tool that allows for editing
and integration with many of the tools that students will need to use.

Although Microsoft Visual C++ is a commonly used compiler, it is _not_ recommended, given that it
conforms to neither ISO/IEC 14882:2011, ISO/IEC 14882:2014, nor ISO/IEC 14882:2017.

### Key competencies
## Content

### Basics

Students are introduced to the principles and practices employed by software developers. Students
without prior programming experience will be exposed to programming for the first time. Students
with prior programming experience will receive a refresher on this topic, which will help provide a
solid foundation for their learning throughout the remainder of the course (and program).

This topic focuses on the core components that compose a basic program.

#### Outcomes

A student:

<dl>
<dt>P1.1</dt>
<dd>
  chooses the correct data structures, algorithms, libraries, and tools for engineering software
</dd>
<dt>P1.2</dt><dd>consults the most appropriate resources for building a system</dd>
<dt>P5.1</dt><dd>wirtes programs that correctly sovle the problem using C++</dd>
<dt>P5.2</dt><dd>writes programs that take advantage of modern C++ programming techniques</dd>
<dt>P6.1</dt><dd>writes unit-tests using the Catch2 framework</dd>
<dt>P8.1</dt>
<dd>
  writes code conforming to _ISO/IEC 14882:2017_ so that it can be targeted on more than one system
</dd>
<dt>P8.2</dt><dd>compiles using high levels of warnings</dd>
<dt>P8.3</dt>
<dd>
  compiles with debugging symbols when they need to understand why their program is failing to
  produce the expected result
</dd>
<dt>P8.4</dt>
<dd>
  compiles with optimisations when they want to run the program in the 'real world' or are
  performing benchmarks
</dd>
<dt>P9.1</dt>
<dd>uses a lint tool (such as clang-tidy) to catch easy-to-make-but-hard-to-spot-mistakes</dd>
<dt>P9.2</dt><dd>configures the lint tool to match the goals and ethics of the course</dd>
<dt>P10.1</dt><dd>creates repositories on GitHub</dd>
<dt>P10.2</dt><dd>regularly commits changes to repositories</dd>
<dt>P10.3</dt><dd>branches, merges, and rebases as new features are added to a project</dd>
<dt>P10.4</dt><dd>pushes commits and branches to a remote repository (on GitHub)</dd>
<dt>P10.5</dt><dd>tracks issues through GitHub's issue tracker</dd>
<dt>P10.6</dt>
<dd>performs Pull Requests to engage in code reviews with collaborators (students and markers)</dd>
<dt>P13.1</dt><dd>uses debuggers to pinpoint flaws in their program design</dd>
<dt>P15.3</dt>
<dd>collaborates with other students when in need of assistance (or to provide assistance)</dd>
</dl>

<table>
  <tr>
    <td><h2>Students learn about<h2></td><td><h2>Students learn to</h2></td>
  </tr>
  <tr>
    <td><dl>
      <dt>Hello, world!</dt>
      <dd><ul>
        <li>what comprises software</li>
        <li>the absolute fundamentals of a C++ program</li>
        <li><code>#include</code> directives
        <li>the <code>main</code> function</li>
        <li>put-to expressions</li>
        <li>compilers</li>
      </ul></dd>
    </dl></td>
    <td><ul>
      <li>write simple computer programs</li>
      <li>compile computer programs</li>
    </ul></td>
  </tr>
  <tr>
    <td><dl>
      <dt>Objects, types, values</dt>
      <dd><ul>
        <li>
          objects, types, values
          <ul>
            <li><code>int</code> for integers</li>
            <li><code>double</code> for rational numbers</li>
            <li><code>char</code> for individual characters</li>
            <li><code>string</code> for strings</li>
            <li><code>bool</code> for Boolean values</li>
            <li><code>auto</code> for automatic type deduction</li>
          </ul>
        </li>
        <li>
          variables
          <ul>
            <li><code>constexpr</code> variables</li>
            <li><code>const</code> variables</li>
            <li>Mutable variables</li>
          </ul>
        <li>
          expressions
          <ul>
            <li>get-from expressions</li>
            <li>arithmetic expressions</li>
            <li>comparison expressions</li>
            <li>assignment expressions</li>
          </ul>
        </li>
        <li>lint tools</li>
        <li>
          conversions
          <ul>
            <li>safe conversions</li>
            <li>unsafe conversions</li>
          </ul>
        </li>
      </ul></dd>
    </dl></td>
    <td>
      <ul>
        <li>choose appropriate data types for their objects' situation</li>
        <li>prefer named constant expressions over variables</li>
        <li>initialise variables at definition</li>
        <li>let the compiler decide the type at compile-time</li>
        <li>declare names as close to their first use as possible</li>
        <li>run a lint tool to check their code is correct</li>
        <li>avoid unsafe conversions</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td><dl>
      <dt>Computation</dt>
      <dd><ul>
        <li>why computation is necessary</li>
        <li>what a programmer's job is</li>
        <li>
          sequence
          <ul>
            <li>expressions</li>
            <li>constant expressions</li>
            <li>conversions</li>
          </ul>
        </li>
        <li>
          selection
          <ul>
            <li><code>if</code>-statements</li>
            <li><code>switch</code>-statements</li>
          </ul>
        </li>
        <li>
          iteration
          <ul>
            <li><code>while</code>-statements</li>
            <li><code>for</code>-statements</li>
          </ul>
        </li>
        <li>code blocks</li>
        <li>
          functions
          <ul>
            <li>definitions</li>
            <li>declarations</li>
            <li>compile-time functions</li>
            <li>pre-conditions</li>
            <li>post-conditions</li>
            <li>regular functions</li>
          </ul>
        </li>
        <li>
          Storing collections
          <ul>
            <li><code>vector</code></li>
            <li>
              <code>vector</code> traversal
              <ul>
                <li><code>operator[]</code></li>
                <li>Range-<code>for</code>-statements</li>
              </ul>
            </li>
            <li>adding elements</li>
            <li>summing elements</li>
            <li>counting elements</li>
            <li>finding elements</li>
            <li>removing elements</li>
          </ul>
        </li>
      </ul></dd>
    </dl></td>
    <td><ul>
      <li>prefer composing logic in order of correctness, simplicity, and efficiency</li>
      <li>
        compose logic using <code>if</code>-, <code>switch</code>-, <code>while</code>-, and
        <code>for</code>-statements
      </li>
      <li>define functions other than <code>main</code></li>
      <li>define functions that execute at compile-time instead of run-time</li>
      <li>declare functions</li>
      <li>store related objects in a <code>vector</code></li>
      <li>perform simple operations on a <code>vector</code></li>
      <li>use simple algorithms that work with <code>vector</code></li>
    </ul></td>
  </tr>
  <tr>
    <td><dl>
      <dt>Errors</dt>
      <dd><ul>
        <li>
          compile-time errors
          <ul>
            <li>syntax errors</li>
            <li>type errors</li>
            <li>non-errors</li>
          </ul>
        </li>
        <li>link-time errors</li>
        <li>run-time errors</li>
        <li>exceptions</li>
        <li>logic errors</li>
        <li>
          debuggers and debugging
          <ul>
            <li>breakpoints</li>
            <li>stepping through code</li>
            <li>stepping over code</li>
            <li>stepping out of code</li>
            <li>inspecting variables</li>
            <li>how to simplify debugging</li>
          </ul>
        </li>
      </ul></dd>
    </dl></td>
    <td><ul>
      <li>prefer compile-time errors to run-time errors and logic errors</li>
      <li>use exceptions to handle run-time errors</li>
      <li>think about debugging <i>before</i> writing code</li>
      <li>debug programs when tests fail</li>
    </ul></td>
  </tr>
  <tr>
    <td><dl>
      <dt>Writing a program</dt>
      <dd><ul>
        <li>
          approaching problem solving
          <ul>
            <li>stages of development</li>
            <li>problem statements</li>
            <li>using libraries</li>
          </ul>
        </li>
        <li>
          prototyping
          <ul>
            <li>trying a first version</li>
            <li>trying a second version</li>
          </ul>
        </li>
        <li>string processing</li>
        <li>
          composite types
          <ul>
            <li><code>struct</code> and <code>class</code></li>
            <li><code>class</code> invariants</li>
          </ul>
        </li>
        <li>
          function technicalities
          <ul>
            <li>pass-by-value</li>
            <li>pass-by-reference</li>
            <li>pass-by-reference-to-<code>const</code></li>
            <li>output parameters and return values</li>
            <li>narrowing conversions revisited</li>
            <li>function call implementation</li>
            <li>scope</li>
            <li>order of evaluation</li>
          </ul>
        </li>
        <li>Git and GitHub
          <ul>
            <li>creating repositories</li>
            <li>cloning repositories</li>
            <li>committing changes</li>
            <li>pushing changes to a remote</li>
          </ul>
        </li>
      </ul></dd>
    </dl></td>
    <td><ul>
      <li>
        plan solutions instead of jumping directly to programming
        <ul>
          <li>build problem statements</li>
          <li>break problems into manageable parts</li>
          <li>look for and consider libraries that can solve parts -- or all -- of the problem</li>
        </ul>
      </li>
      <li>
        meet problem requirements and avoid feature creeping
        <ul>
          <li>build one part of a program at a time</li>
          <li>assemble successful parts into larger solutions</li>
        </ul>
      </li>
      <li>experiment with different solutions</li>
      <li>critique and improve their solution</li>
      <li>
        prefer
        <ul>
          <li><code>class</code>es for types with invariants</code>
          <li><code>struct</code>s for types with independent data members</li>
        </ul>
      </li>
      <li>
        prefer
        <ul>
          <li>return values to output parameters</li>
          <li>passing by value for fundamental type-input parameters</li>
          <li>
            passing by reference-to-<code>const</code> for non-trivial composite type input 
            parameters
          </li>
          <li>keeping objects in as small a scope as possible</li>
        </ul>
      </li>
      <li>
        use Git
        <ul>
          <li>create GitHub repositories</li>
          <li>clone a repository from GitHub</li>
          <li>commit changes to a Git repository</li>
          <li>push commits to a remote Git repository (GitHub)</li>
        </ul>
      </li>
    </ul></td>
  </tr>
  <tr>
    <td><dl>
      <dt>Completing a program</dt>
      <dd><ul>
        <li>Git branches, merging, rebasing, and cherrypicking</li>
        <li>determining if their solution actually solves the problem</li>
        <li>error handling and recovery</li>
        <li><code>std::variant</code></li>
        <li>scoped enumerations</li>
        <li>unit testing</li>
        <li>code layout</li>
        <li>comments</li>
      </ul></dd>
    </dl></td>
    <td><ul>
      <li>
        use Git
        <ul>
          <li>create branches in Git repositories for changes</li>
          <li>merge Git branches once work is complete</li>
          <li>merge a single commit to a Git branch from many</li>
          <li>squash Git branches when only one commit is ideal</li>
          <li>perform code reviews via GitHub pull requests</li>
        </ul>
      </li>
      <li>critique and improve their solution</li>
      <li>use <code>std::variant</code> when alternate types need to be handled</li>
      <li>use exceptions to handle errors</li>
      <li>write unit-tests</li>
      <li>check their program meets the problem requirements</li>
    </ul></td>
  </tr>
</table>

### Input and output

<table>
  <tr>
    <td><b>Students learn about</b></td>
    <td><b>Students learn to</b></td>
  </tr>
  <tr>
    <td>
      <b>Input and output streams</b>
    </td>
    <td></td>
  </tr>
  <tr>
    <td>
      <b>Customising input and output</b>
    </td>
    <td></td>
  </tr>
  <tr>
    <td>
      <b>A display model</b>
    </td>
    <td></td>
  </tr>
  <tr>
    <td>
      <b>Graphics</b>
    </td>
    <td></td>
  </tr>
  <tr>
    <td>
      <b>Graphing functions and data</b>
    </td>
    <td></td>
  </tr>
  <tr>
    <td>
      <b>Graphical user interfaces</b>
    </td>
    <td></td>
  </tr>
</table>


### Data and algorithms
<table>
  <tr>
    <td><b>Students learn about</b></td>
    <td><b>Students learn to</b></td>
  </tr>
  <tr>
    <td><b>Vector and Free Store</b></td>
    <td></td>
  </tr>
  <tr>
    <td><b>Vectors and arrays</b></td>
    <td></td>
  </tr>
  <tr>
    <td><b>Vector, templates, and exceptions</b></td>
    <td></td>
  </tr>
  <tr>
    <td><b>Containers and iterators</b></td>
    <td></td>
  <tr>
    <td><b>Algorithms and maps</b></td>
    <td></td>
  </tr>
</table>

### Broadening the view
<table>
  <tr>
    <td><b>Students learn about</b></td>
    <td><b>Students learn to</b></td>
  </tr>
  <tr>
    <td>
      <b>Ideals and history</b>
    </td>
    <td></td>
  </tr>
  <tr>
    <td><b>The C Programming Language</b></td>
    <td><b></b></td>
  </tr>
  <tr>
    <td><b>Heterogeneous programming</b></td>
    <td></td>
  </tr>
</table>

## Course requirements

This course has no formal requirements. Students enrolling in the course are assumed to have
developed intermediate skills in high school calculus and algebra:

* 
* 
* 
* 
* 
* 

Students who have not developed the above skills will likely struggle with the course material.

### When to study this course

This course is best studied during the first semester of a computer science or engineering program,
absent of other programming courses (particularly ones that teach C, Java, C#, or Python). If
possible, this course should be taken before any course that teaches the C programming language.

It is understood that many university programs will have strict curriculums and that students
probably cannot meet this recommendation (or are advised by their faculty to avoid following it).
As such, the next recommended time to study this course is after a third semester of university, so
that this course may serve as a refresher for the things that students have forgotten or disregarded
since their first year of university. In this case, combining the course with courses that teach
other programming lanugages is inevitable, but it shouldn't be an issue this late into a program.

Given that this course doubles as 'the C++ course', students will need to take this course if they
wish to formally learn C++, or in the case that they've already
learnt C++, deepen their learning.

## Post-course opportunities

Computer software is used in everyday life to the point where a large portion of the global
population now depend upon it for survival. Software is becoming evermore complex; this course does
not aim to make you a software engineering expert. It aims to give you a rich toolset so that you
may enter the workforce with enough knowledge to become an expert in time.

[Many software solutions have been developed with C++](stroustrup.com/applications.html). Many more
are not listed, but if you find this course interesting and keep practicing, you might like to
consider applying for a software engineering position with:

<table>
  <tr>
    <td><a href="https://www.amazon.jobs/en/teams/a9">A9 (Amazon)</a></td>
    <td><a href="http://www.adobe.com/careers.html">Adobe Systems</a></td>
    <td><a href="https://jobs.amd.com">AMD</a></td>
    <td><a href="https://jobs.zenimax.com/locations/view/4">Bethesda Game Studios</a></td>
    <td><a href="https://www.bloomberg.com/careers">Bloomberg</a></td>
  </tr>
  <tr>
    <td><a href="http://www.boeing.com/careers">Boeing</a></td>
    <td><a href="https://www.codeplay.com/company/careers">Codeplay Software</a></td>
    <td><a href="https://www.creative-assembly.com/careers">Creative Assembly</a></td>
    <td><a href="http://www.crytek.com/career">Crytek</a></td>
    <td><a href="https://www.dropbox.com/jobs">Dropbox</a></td>
  </tr>
  <tr>
    <td><a href="https://drw.com/careers">DRW Trading Group</a></td>
    <td><a href="https://www.facebook.com/careers">Facebook</a></td>
    <td><a href="https://careers.google.com">Google</a></td>
    <td><a href="https://jobs.zenimax.com/locations/view/1">id Software</a></td>
    <td><a href="https://www.imgtec.com/careers">Imagination Technologies</a></td>
  </tr>
  <tr>
    <td><a href="https://www.imc.com/eu/careers">IMC</a></td>
    <td><a href="http://jobs.intel.com">Intel</a></td>
    <td><a href="https://careers.microsoft.com">Microsoft</a></td>
    <td><a href="https://www.morganstanley.com/people-opportunities/students-graduates">Morgan Stanley</a></td>
    <td><a href="https://www.naughtydog.com/careers">Naughty Dog</a></td>
  </tr>
  <tr>
    <td><a href="https://www.nintendo.com/corp/jobs.jsp">Nintendo</a></td>
    <td><a href="http://www.nvidia.com/object/careers.html">nVidia</a></td>
    <td><a href="https://www3.oculus.com/en-us/careers">Oculus</a></td>
    <td><a href="https://www.qualcomm.com/company/careers">Qualcomm</a></td>
    <td><a href="https://www2.renesas.eu/jobs">Renesas</a></td>
  </tr>
  <tr>
    <td><a href="https://www.sony.net/SonyInfo/Careers">Sony</a></td>
    <td><a href="http://www.spacex.com/careers">SpaceX</a></td>
    <td><a href="https://www.synopsys.com/company/synopsys-careers.html">Synopsis</a></td>
    <td><a href="https://www.tesla.com/careers">Tesla</a></td>
    <td><a href="http://www.valvesoftware.com/jobs/job_postings.html">Valve</a></td>
  </tr>
</table>

This course is not affiliated with any of the listed companies, nor does it guarantee you a position
with any of them. The companies listed here may or may not rotate, and listings will sometimes be
updated to reflect current events. This cannot always be guaranteed.

## Contact hours

This syllabus recommends the following as a minimum number of hours students should spend
interacting with university staff:

| Component | Recommended time                           |
|-----------|--------------------------------------------|
| Lectures  | Four hours, split into two two-hour blocks |
| Tutorials | One hour per week                          |
| Labs      | Two hours per week, separate to tutorials  |

Lecturers will also provide at least two hours of consultation time outside of lecture times. Please
contact individual lecturers to find out their contact hours.

## Assessment and reporting

The course is designed to have weekly laboratories and four assignments. Both are expected to take a
significant portion of your study week. There is a final practical exam at the end of the course.

| Assessment  | Weight | Minimum mark to pass | Supplementary                                 |
|-------------|--------|----------------------|-----------------------------------------------|
| Labs        | 15%    | 7/15                 | No, but only your top ten labs are marked     |
| Assignments | 35%    | 18/35                | No, but extensions are possible in some cases |
| Exam        | 50%    | 25/50                | Yes, but there will be an oral component too  |
| Bonus       |  2%    | 0/2                  | No                                            |

Students who are unable to submit labs can contact their tutor and the lecturer in charge to arrange
for the weighting of this component to be transferred to the final exam (total weighting 65%). In
this case, your exam will also have an oral component. The oral section is necessary to help combat
academic misconduct, and to keep matters fair -- each lab has an oral section too.

Some labs are designed to have an individual component and a group component. Failure to
satisfactorily complete the group component will result in a zero for the individual component.
Students who fail to complete the group component three or more times will have their final mark
capped at **45/100**. Students affected by inactive group members will be given the option to
complete anything that can be completed by the following lab.

### Ideas for assignments

The assignments in this course are not designed to be easy, and should give students a taste for a
range of topics that programming can be applied to. Furthermore, students should be exposed to
overlapping projects. As such, the deadline for each assignment will often overlap with the starting
period for the next one.

#### Assignment 1 (Start of Week 1 -- end of Week 4, 4 weeks)

* String processing
* TODO

#### Assignment 2 (Start of Week 4 -- end of Week 6, 3 weeks)

* Numerical processing
* GUI work
* TODO

#### Assignment 3 (Start of Week 6 -- end of Week 9, 3 weeks)

* Embedded systems programming
* TODO

#### Assignment 4 (Start of Week 8 -- end of Week 13, 6 weeks)

* **Extending a project**. This is, by far, the most abitious assignment. Students are given working
  code (that is probably poorly written) and asked to extend it. Parts of the program will need to
  be fixed, parts of the program will need to be extended, and sometimes both may need doing. In
  some areas, an entire section may need to be re-written, as it is either completely incorrect, or
  there is an enormous design flaw (symptom: undefined behaviour).

  Students should have enough confidence to get their hands dirty in this assignment, but it needs
  to be stressed that a complete re-write of the entire project is not acceptable: they will need to
  work with the code they have been given for the most part. GitHub issues, milestones, and project
  tracking should be released with the assignment from the parent fork to guide students along the
  way to completing this assignment.

  This assignment aims to capture a real-world project. As such, parts of it should be well-oiled
  and 'beautiful', and other parts of it should be questionable (sometimes more C-like than
  C++-like, sometimes simply 'clever', or poorly documented). Students will need to work with both
  parts in order to successfully complete the assignment.

  In order to pull this off successfully, the project should be related to content from one of the
  previous assignments' topics.

### Bonus marks

See [Course evaluation and development](#course-evaluation-and-development).

### Extensions for assingments

Extensions must be made to the lecturer in charge, in writing, no later than twenty-four hours
before the assignment deadline.

### Lab exam

There will be a three-hour, closed-book laboratory exam for this course in the exam period. Some
documentation will be provided, so it is recommended that you familiarise yourself with the
documentation on [C++ Reference] and the [C++ Core Guidelines] early on in the course for speedy
lookups in the exam. Access to the Web is not permitted.

All material covered in this course, including lectures, tutorials, assignments, set readings, and
problem sets are examinable.

You will be asked to solve a series of problems using C++, and will need access to both a compiler
and documentation, which is why this is a lab exam. Exam marking will be broken into two parts:

Exam correctness is evaluated through auto-marking. Be sure to regularly submit your work, as any
submissions made after the three-hour allotted time period will be ignored.

The lab exam is a hurdle requirement: you must pass the final exam to pass the course.

## Course evaluation and development

Student feedback on this course will be obtained via electronic survey at the end of semester, and will be used to make continual improvements to the course.

You are encouraged to provide informal feedback to throughout the semester, and to let the lecturer know of any problems as soon as they arise. All reasonable suggestions and concerns will be carefully considered, and every effort will be made to address them.

Due to abysmal participation in previous years, this year will feature a non-anonymous survey worth
two bonus marks. These bonus marks can be used to prop you up. You may submit either the
non-anonymous feedback, the anonymous feedback, or both (preferable). **No impact will be made to
student marks if your non-anonymous review is less-than-pleasant: an honest scathing review is far
more valuable than a calming review for two marks.**

## Prescribed texts

The prescribed text for this course is _[Programming -- Principles and Practice Using C++]_ (Second
edition), by Bjarne Stroustrup.

There will be prescribed readings, and many of the tutorial and laboratory questions will be derived
from this book, so it is _strongly_ recommended that you purchase a copy in Week 1. Due to time
restrictions, some content won't be covered in class, and will only be accessible by reading the
textbook.

## Recommended texts

* Students familiar with another programming language may like to read _[A Tour of C++]_, by Bjarne
  Stroustrup before they begin PPP; this will given you a taste of what is to come, without bogging
  you down in the details.
* Students wishing to have a reference handy should consult [C++ Reference].
* Students wishing to have an opinionated reference handy should consult _[The C++ Programming
  Language]_ (Fourth edition), by Bjarne Stroustrup.
* We will be using the [C++ Core Guidelines] as a 'style guide'. You aren't required to read this
  (it is very large), but if you are interested, you might like to take a peek.

## References


[Programming -- Principles and Practice Using C++]: http://stroustrup.com/programming.html
[A Tour of C++]: http://stroustrup.com/Tour.html
[C++ Reference]: en.cppreference.com
[C++ Core Guidelines]: https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md
[The C++ Programming Language]: http://stroustrup.com/4th.html